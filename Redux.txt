Redux : State managment libarbar

3 Main concepts

Action, Reducers, store


1) Store : is responsible to store application state, consider as a warehouse which store all items
2) Reducers: transform current state and action into new state, consider as robots doing all the work, many robots divided many works
3) Action : Telling reducers what to do, for eg adding item or removing item. Instructions given to robot, telling robots actions

To quickly recap, the store is responsible for storing the application state; reducers transform the current state and a given action into a new state; and finally, actions tell the reducer what to do— for example, adding an item or removing an item. 

Priceples:
1)Single source of truth: all app state is stored in signle tree, storing in single tree easy serilize & store for state later 
2)State is read only: Redux use one way data flow, store flows to components but components doesnt direactly change statein store,
Change in application takes only in store
3)Change through pure functions: These functions are pure, and simply return the next state based on a given action and the current state. The function being pure means that it will always return the same result when given the same action and state. It cannot use any data that is not in the state or part of the action. This means we need to pay extra attention to immutability. We don't want to modify any data that is outside of our reducer function, including the state itself.


____________________________________________________________________
In this module, we're going to take a look at how Redux works on a high level. We're not going to dive into any specifics just yet. Our aim here is to get a bird's eye view on how Redux works and what parts it consists of. Redux has three main concepts or components: actions, reducers, and the store. To more easily understand these components and how they work together, let's start with an analogy. Imagine there is a high-tech warehouse with actual robots doing all the work for us. The warehouse itself is responsible for storage, so that's our store. The robot does all the heavy lifting and is responsible for updating our state. He's our reducer. A store can have multiple reducers. This means that our little robot friend doesn't have to do everything in the warehouse, but only the parts that we tell it to care about. As our store grows larger, it will make sense to introduce multiple reducers, each responsible for their own little part of the warehouse. Finally, as their human overlords, we tell the robots what to do. The instructions we give the reducers are called actions; nothing more than an object with a specific action type. An action type lets the reducer know what it's supposed to do. For example, we could instruct the robot to prepare an item for loading, to remove an item from the warehouse, and so on. We can also add more data to the action. This is called the payload. Let's say we want to add a new item to the warehouse. We need to not only tell our robot to store the item, but also what to store. In this case, that would be the data for the item we're going to add. Let's leave behind the analogy and take a look at the mental model of the actual Redux components. First of all, let's start with the store itself. The store holds the current state. It also has a root reducer, which is either a simple function or a combination of smaller reducer functions. Think back to the robots in our analogy: we can either have one robot for a simple application, or split up our reducer into multiple reducers. We should consider splitting up the reducer once our state gets too unwieldy to manage with just one function. And the last piece of our Redux puzzle is the action. This tells the reducer what it should do in order for it to return a new state. For example, an action could be to add an item to the store. So, by now, you might be wondering: where do those actions actually come from? Well, the majority of actions that are dispatched to a Redux store come from your application's UI. For example, let's say we filled out a form to add a new item to the store. First, we dispatched the right action to the store, and afterwards, the reducer will return the new state that includes the new item. Redux attempts to solve the gnarly issue of state management by requiring us to follow certain rules and principles. There are three main principles: the single source of truth, state is read-only, and changes are made with pure functions. Let's start off with the first one: the single source of truth. All of the application state in Redux is stored in a single tree. That might seem a little weird at first, but it'll make sense after a while. Also, due to Redux's modular nature, we can still manage code in small chunks instead of working on one big state tree. Having our application state in one big tree also allows us to easily serialize and store the application state for later use, for example. The second principle is that state is read- only. Redux uses one-way data flow. This means that the data from our store flows down to the components, but components cannot directly modify the data in the store. To do so, they would have to dispatch actions instead. This means that changes to the application state can only happen in one place: the store. That makes it much easier for us to track changes across our application state, because we only have to look in one place. And finally, the last principle is that changes are made with pure functions. We already know that the state tree is transformed by reducers, which are just regular functions. These functions are pure, and simply return the next state based on a given action and the current state. The function being pure means that it will always return the same result when given the same action and state. It cannot use any data that is not in the state or part of the action. This means we need to pay extra attention to immutability. We don't want to modify any data that is outside of our reducer function, including the state itself. We simply return a new state object that has been updated. We already know when to use Redux, but we should take a second to also talk about where to use Redux. Using Redux doesn't mean that you should store every small bit of state in your application in the Redux store. A good rule of thumb, given by Redux's creator Dan Abramov, is to do whatever is less awkward. Sometimes, it just doesn't make sense for us to store a component state in a global Redux store. For example, if we have some kind of toggle button, we really don't have to store its enabled state in a global store. The component itself is perfectly capable of keeping track of its own UI state. State should be stored globally in Redux when it gets too complex to handle in a single component, or when several unconnected components need access to the same data. For example, let's say we're composing an email draft and want to get back to it later. That means we're going to close our email composer component, resulting in its local state being lost. Using Redux, we can store our draft data in the store and use it later on to render a draft preview, or just to open the editor again with the draft content. To quickly recap, the store is responsible for storing the application state; reducers transform the current state and a given action into a new state; and finally, actions tell the reducer what to do— for example, adding an item or removing an item.
____________________________________________________________________
 